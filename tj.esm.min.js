function y(s){if(s===null)return{json:"null"};if(s===void 0)return{json:void 0};const r=[],f=[""],o=new Map;function t(u,e){let n;r.length&&(n=r[r.length-1],n.iteration++,n.iteration>n.count&&(n.type==="object"&&f.pop(),r.pop(),n=r[r.length-1],n.iteration++)),n&&(e=n.value[u]);let i=`${f[f.length-1]}${u}`;const g=typeof e;if(g==="object"&&e!==null){let p=0,c="undefined";if(e instanceof Date?(c="date",e=e.toISOString()):e instanceof Set?(e=Array.from(e),p=e.length,c="set"):e instanceof Map?(e=Object.fromEntries(e),p=Object.keys(e).length,c="map"):e instanceof Array?p=e.length:e instanceof RegExp?(c="regexp",e=String(e)):e instanceof Error?(c="error",e={name:e.name,message:e.message,stack:e.stack},r.push({type:"object",value:e,count:3,iteration:0})):(p=Object.keys(e).length,c="object"),c!=="undefined"&&c!=="object"&&o.set(i,c),p!==0)return r.push({type:c,value:e,count:p,iteration:0}),u&&c==="object"&&f.push(`${i}.`),e}if(g==="bigint")return o.set(i,"bigint"),String(e);if(g==="number"){if(e===Number.POSITIVE_INFINITY)return o.set(i,"infinity"),"Infinity";if(e===Number.NEGATIVE_INFINITY)return o.set(i,"-infinity"),"-Infinity";if(Number.isNaN(e))return o.set(i,"nan"),"NaN"}return typeof e=="undefined"?(o.set(i,"undefined"),null):e}return{json:JSON.stringify(s,t),meta:o.size===0?void 0:Object.fromEntries(o.entries())}}function N({json:s,meta:r}){if(!s)return null;const f=JSON.parse(s);return r&&I(f,r),f}function I(s,r){const f=Object.keys(r);for(let t=0;t<f.length;t++){const b=f[t];o(s,b.split("."),r[b])}return s;function o(t,b,u,e=0){const n=b[e];if(e<b.length-1){o(t[n],b,u,e+1);return}const i=t[n];switch(u){case"date":t[n]=new Date(i);break;case"set":t[n]=new Set(i);break;case"map":t[n]=new Map(Object.entries(i));break;case"regexp":const g=/^\/(.*)\/([dgimsuy]*)$/.exec(i);if(g)t[n]=new RegExp(g[1],g[2]);else throw new Error(`Invalid regexp: ${i}`);break;case"bigint":t[n]=BigInt(i);break;case"undefined":t[n]=void 0;break;case"infinity":t[n]=Number.POSITIVE_INFINITY;break;case"-infinity":t[n]=Number.NEGATIVE_INFINITY;break;case"nan":t[n]=NaN;break;case"error":const p=new Error(i.message);p.name=i.name,p.stack=i.stack,t[n]=p;break}}}function m(s){return JSON.stringify(y(s))}function k(s){const r=JSON.parse(s);return r?N(r):null}const j={serialize:y,stringify:m,deserialize:N,parse:k,applyMeta:I};var a=j;export{I as applyMeta,a as default,N as deserialize,k as parse,y as serialize,m as stringify};
